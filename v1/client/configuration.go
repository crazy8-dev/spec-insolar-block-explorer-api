/*
 * Insolar Explorer API
 *
 * [Insolar Explorer](https://github.com/insolar/block-explorer)'s REST API documentation.  Insolar Explorer is a service that allows users to search for and view the contents of individual transactions, records, lifelines, jet drops and jets.  * Record—minimum unit of storage that contains an associated request, response, and maintenance details * Lifeline—sequence of records for object state where an object is a smart contract instance * Jet drop—unit of storage for jets * Jet—groups of lifelines  Main API endpoints include: * Search endpoint: `/api/v1/search` * Endpoints for each entity type:   * Records: `/api/v1/jet-drops/{jet_drop_id}/records`   * Lifeline: `/api/v1/lifeline/{object_reference}/records`   * Pulse: `/api/v1/pulses/{pulse_number}`   * Pulses: `/api/v1/pulses`   * Jet drop by jet ID: `/api/v1/jets/{jet_id}/jet-drops`   * Jet drop by its ID: `/api/v1/jet-drops/{jet_drop_id}`   * Jet drop by pulse number: `/api/v1/pulses/{pulse_number}/jet-drops`  A search request first gets to the search endpoint where its the entity type `value` is identified.  It then is redirected to the appropriate endpoint for detailed metadata to show the user on the Insolar Explorer Web UI.  Search results can be paginated. Pagination parameters are optional and include: * Starting point that depends on the searched entity type: `from_index`, `from_pulse_number`, or `from_jet_drop_id` * Number of entries per page: `limit` * Number of entries to skip from the starting point to show on a new page: `offset`  For example, for 10 entries per page starting from the pulse number 431920 for a set of 200 entries: `<example.com>/<api_endpoint>?<params>&from_pulse_number=431920&limit=10&offset=0`.  Search results can additionally be sorted by `index` or `pulse` in the descending or ascending order.  For example, `<example.com>/<api_endpoint>?<params>&sort_by=-index`.  Search results shown to the user on the Insolar Explorer Web UI may miss some data. The `Reload` button gets the missed data via requests to the API with additional filtering parameters: * `jet_drop_id_gt` and `jet_drop_id_lt` to obtain missing data within a range of jet drops (greater than, less then) * `pulse_number_gt` and `pulse_number_lt` to obtain missing data within a range of pulses (greater than, less then) * `timestamp_gte` and `timestamp_lte` to obtain missing data within a timespan (greater than or equal, less then or equal)  For example, `<example.com>/<api_endpoint>?<params>&pulse_number_gt=431902&pulse_number_lt=431904`. 
 *
 * API version: 1.0.0
 * Contact: dev-support@insolar.io
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package client

import (
	"fmt"
	"net/http"
	"strings"
)

// contextKeys are used to identify the type of value in the context.
// Since these are string, it is possible to get a short description of the
// context key for logging and debugging using key.String().

type contextKey string

func (c contextKey) String() string {
	return "auth " + string(c)
}

var (
	// ContextOAuth2 takes an oauth2.TokenSource as authentication for the request.
	ContextOAuth2 = contextKey("token")

	// ContextBasicAuth takes BasicAuth as authentication for the request.
	ContextBasicAuth = contextKey("basic")

	// ContextAccessToken takes a string oauth2 access token as authentication for the request.
	ContextAccessToken = contextKey("accesstoken")

	// ContextAPIKey takes an APIKey as authentication for the request
	ContextAPIKey = contextKey("apikey")

)

// BasicAuth provides basic http authentication to a request passed via context using ContextBasicAuth
type BasicAuth struct {
	UserName string `json:"userName,omitempty"`
	Password string `json:"password,omitempty"`
}

// APIKey provides API key based authentication to a request passed via context using ContextAPIKey
type APIKey struct {
	Key    string
	Prefix string
}


// ServerVariable stores the information about a server variable
type ServerVariable struct {
	Description  string
	DefaultValue string
	EnumValues   []string
}

// ServerConfiguration stores the information about a server
type ServerConfiguration struct {
	Url string
	Description string
	Variables map[string]ServerVariable
}

// Configuration stores the configuration of the API client
type Configuration struct {
	BasePath      string            `json:"basePath,omitempty"`
	Host          string            `json:"host,omitempty"`
	Scheme        string            `json:"scheme,omitempty"`
	DefaultHeader map[string]string `json:"defaultHeader,omitempty"`
	UserAgent     string            `json:"userAgent,omitempty"`
	Debug         bool              `json:"debug,omitempty"`
	Servers       []ServerConfiguration
	HTTPClient    *http.Client
}

// NewConfiguration returns a new Configuration object
func NewConfiguration() *Configuration {
	cfg := &Configuration{
		BasePath:      "http://example.com",
		DefaultHeader: make(map[string]string),
		UserAgent:     "OpenAPI-Generator/1.0.0/go",
		Debug:         false,
		Servers:       []ServerConfiguration{
			{
				Url: "example.com",
				Description: "Test server.",
			},
		},
	}
	return cfg
}

// AddDefaultHeader adds a new HTTP header to the default header in the request
func (c *Configuration) AddDefaultHeader(key string, value string) {
	c.DefaultHeader[key] = value
}

// ServerUrl returns URL based on server settings
func (c *Configuration) ServerUrl(index int, variables map[string]string) (string, error) {
	if index < 0 || len(c.Servers) <= index {
		return "", fmt.Errorf("Index %v out of range %v", index, len(c.Servers) - 1)
	}
	server := c.Servers[index]
	url := server.Url

	// go through variables and replace placeholders
	for name, variable := range server.Variables {
		if value, ok := variables[name]; ok {
			found := bool(len(variable.EnumValues) == 0)
			for _, enumValue := range variable.EnumValues {
				if value == enumValue {
					found = true
				}
			}
			if !found {
				return "", fmt.Errorf("The variable %s in the server URL has invalid value %v. Must be %v", name, value, variable.EnumValues)
			}
			url = strings.Replace(url, "{"+name+"}", value, -1)
		} else {
			url = strings.Replace(url, "{"+name+"}", variable.DefaultValue, -1)
		}
	}
	return url, nil
}
